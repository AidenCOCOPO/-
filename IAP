1.time_wait是哪一方的？有什么作用？
答：time_wait是主动发起断开方的一个状态，它是在收到被动方FIN报文，响应ACK之后的一个状态，它的目的有两个，第一是为了防止相同四元组的旧数据被接收到，因为相同四元组的旧数据是有可能被新连接接受到的，就是当序列号seq_num碰巧相同，且四元组是一样的时候。所以设置2MSL的等待时间，让两个方向上的数据包都被丢弃，这样保证再出现的数据包是新连接产生的。第二是根据RFC(互联网协议的相关标准)指出，为了确保被动方可以收到最后一次ACK，从而正常关闭。因为当最后一次ACK丢失后，被动方若在一定时间内没有收到ACK，会触发重发机制，重新发送FIN报文，若此时主动方已经关闭，则收不到该报文了。
2.若被动方无法正常关闭有什么影响？
答：首先当被动方是服务器方时，若无法正常关闭，处理该连接的线程就得不到正常释放，占用服务器内存资源，当内存资源被占满时，就无法处理新连接了。当被动方是客户端时，若无法正常关闭，则会导致该连接端口无法正常释放，浪费端口资源，当端口资源被沾满就无法发起新的连接了。
3.TCP time_wait过多会有什么影响？怎样处理？
答：time_wait过多时，总的来说会消耗系统资源，使得系统资源得不到释放。当客户端time_wiat过多时，会导致端口资源得不到释放，若将端口资源耗尽时，就无法发起新的连接了。当服务端time_wait过多时，会导致处理该连接的线程资源得不到释放，对应的内存资源也得不到释放，当内存资源被占满时，那么无法处理新的连接了(以DDOS攻击为例，将你内存资源耗尽，从而无法正常工作)。解决方式有以下三种。首先OS可以随机将一个time_wait状态超过1s的连接(端口或线程资源)分配给新的连接，不过这个需要开启TCP对时间戳的支持，第二呢则是暴力方法了，若time_wait的数量超过某一个阈值，则直接进行重置，第三呢则是利用RST标志位，直接中断连接，不过可能会造成数据丢失，因为RST报文会直接将缓冲区内数据丢弃，且接收方也不用响应ACK。
4.为什么是2MSL?什么是2MSL？
答：2MSL即两个最大报文生存时间。TCP的time_wait状态是从发起方发出ACK之后开始计时，2MSL的设计目的保证发起方可以接收到被动方可能发送的FIN重传报文，因为ACK过去加上FIN重传的最大时间正好是2MSL的时间。MSL不同的操作系统，定义时间不一样，如CentOS就是2MSL为60s。
5.TCP的保活机制
答：即在一定时间内该TCP连接没有任何活动，则会发送探测报文，若连续几个探测报文都得不到回应，则判定该连接已经死亡。且情况可以分为以下三种，第一种，当对端是正常工作的，只是没有发送消息而已，那么当发送探测报文的时候，会得到响应，等待时间会被重置，第二种，当对端崩溃了，但又进行了重启，所以对端是可以接收探测报文的，但由于不符合TCP连接的步骤，所以会以RST报文响应，中断连接。第三种，当对端真的死去，几次探测报文没有得到响应，那么会认定该连接已死亡，断开连接。

6.TCP中断重连怎么处理？
答：如果对方某个时刻没有及时响应，会触发重传机制，若超出一定时间，则会按照保活机制设定的规则进行操作。
7.HTTP的keep-alive与TCP的keep-alive有什么区别关系？
答：二者的目的是不一样的，HTTP的keep-alive代表着这是一个长连接，不会发送完HTTP请求后立即断开，而是会保持连接，可发送多个HTTP请求。而TCP的keep-alive则是TCP的一种保活机制，检查TCP连接状态，判断是否已经死亡。
8.对socket如何理解？
答：socket就是对复杂的TCP/IP的一个封装，通过socket我们可以直接进行通信连接而不用管理复杂的TCP/IP细节。
9.TCP初始序列号是怎么设计的？
答：初始序列号ISN=M+F,M是一个计时器函数，每隔四毫秒+1,F是一个hash函数，它的参数是四元组。
10.为什么初始序列号ISN每次都是不相同的？
答：每次建立连接前都要重新初始序列号是为了将历史连接丢弃掉。
11.有了IP分包为什么还需要TCP分包？
答：当数据包大小超过了物理链路所能发送的最大容量，就会在IP层产生分片。并由目的端IP层进行重组，其中IP头中的几个关键字可以保证IP的有效重组，分别是标识(代表是否由同一个IP进行分片)，flag位(有三位，第一位没有使用，第二位表示是否可以分片，第三位表示是否还有后续)，以及偏移(偏移量*8代表了在重组报文后的位置)，若重组之后在报文在传输层进行头部校验时，发现错误，则会丢弃，然后进行整个报文的重发。因为IP层并没有像TCP那样的重发机制，所以当丢失报文后，会进行整个数据包的重传，浪费流量。但TCP分包时，当发生丢包时，只需要重传对应丢失的包即可。好比IP层分包重组时，是先统一收到，然后重组，当重组后才会发现是否有丢包，而TCP分包则类似与边收边重组，当发现丢包时，立马要求重传。
12.TCP丢包怎么处理？具体发什么信号？
答：TCP丢包后会触发重发机制。TCP的重发机制有两种，分别是超时重发以及快速重发。超时重发是在设定时间内没有收到ACK，就会被认定发生了丢包，会进行重发。超时时间这个值是会比报文往返时间RTT稍大一点，且TCP采用的是超时时间加倍，就是出发了超时重传后，下一次的超时时间会变为之前的两倍。快速重发就是连续收到了三次相同的ACK，此时就认定发什了丢包。但是此时是不知道是这三个连续的ACK是谁返回的，所以无法确定重发哪个。此时产生了一个方法叫做选择性重传SACK。就是在返回相同ACK的同时还会返回SACK。SACK代表此时收到的数据范围，这样就可以具体知晓是哪一段报文丢失了，然后进行对应报文重传即可。
13.tcp从网卡到程序内存的过程？经过哪几次拷贝？
答：经过一次零拷贝mmap，由网卡缓存将数据直接copy到应用程序内存。
14.零拷贝的理解
答：(sendfile)若不使用零拷贝时，将磁盘数据通过网卡发送出去将需要四次内核与用户态之间的切换以及四次数据copy过程，如果使用了零拷贝，由内核缓存区直接将数据copy至网卡缓存区，就只剩下两次内核与用户态的切换以及只需要两次copy操作，可以大大提高数据传输效率。https://www.jianshu.com/p/193cae9cbf07(有个直接内存访问DMA，内存映射MMAP)
15.NIO，BIO，AIO的理解
答：NIO一种非阻塞式IO，即当有数据时才会去读，当有数据时或者有空间时才会去写，而不是一直阻塞等待。https://www.imooc.com/article/265871。BIO，其实就是阻塞IO，AIO则是异步IO。
16.epoll，select，poll的理解(IO复用)
答：select，poll，epoll都是IO复用技术的一种体现，所谓IO复用通俗来讲就是一个线程可以监听多个socket，往常都是一个socket分配一个线程。IO复用的好处可以提高服务器处理连接的能力。他们其实就是将多个socket放入数组或链表中，然后专门的一个线程去监听这些连接，哪个socket有变换就去处理哪个。但是也有些区别。select存放socket的是数组，所以数组的大小被操作系统限制了，Linux限制的大小为1024，且每次select都需要将数组进行用户与内核态的copy，且每次都是遍历数组，当数组很大时，十分耗时，时间复杂度为O(n)。poll与select类似，但是poll存放socket的是链表，因此没有大小限制，也是采用遍历的方式查找有变化的socket，时间复杂度也是O(n)，也需要进行用户态与内核态的copy操作。epoll则是采用红黑存储socket，且有一个回调函数，当某个socket发生变化，则会进行回调，将该socket存入就绪链表，所以查找有变化socket时直接查询就绪链表就好，时间复杂度为O(1)，且epoll利用mmap技术，所以不需要内核与用户的频繁拷贝。select与poll是同步非阻塞的，而epoll则是异步非阻塞的。
17.在浏览器内输入一个URL后，发生了什么？
答：首先先解析URL，前面一部分为服务器域名，后面一部分为服务器上的文件路径。利用DNS协议进行域名的解析，获取服务器的IP地址，然后与服务器进行三次握手建立连接，然后发送HTTP报文，服务器响应对应请求文件，浏览器接收到以后，将文件进行渲染。其中DNS解析的过程是，首先在浏览器缓存中查找是否有域名对应的IP地址，若没有则向操作系统的HOST文件查找，若还是没有则向本地DNS服务器进行递归查找，本地DNS服务器若也没有，则会向根服务器进行迭代查找，从根服务器到顶级域名服务器再到权威域名服务器就这样一级一级查找，查找到后返回对应IP(这里应该注意防止DNS劫持，以及利用DNS原理进行DDOS攻击)，然后本地域名服务器，浏览器等分别进行定时的缓存。
18.TCP粘包问题
答：只有TCP才可能发生粘包问题，UDP是不会发生的，因为TCP是面向流的发送，而UDP则是面向报文发送，所谓的面向流就是不会一整块一整块的发送，而是当TCP的数据过大时会进行拆包，过小时会进行与其他数据合并再发送，而UDP则是一整块发送，若过大则会在IP层进行拆分。如何解决TCP粘包问题？就拿HTTP举例，可以在HTTP报文头部自定义字段，如加一个完整报文的长度，若此次没接收完，下一个继续接收。或者在数据里加标志，标识此处完结或者还有后续。

1.OSI与TCP/IP各层结构与功能，都有哪些协议
答：OSI分为7层，从下到上分别为物理层，链路层，网络层，传输层，会话层，表示层，应用层。TCP/IP则分为4层，从下到上分别为网络接口层，网络层，传输层，应用层。应用层的协议一般有HTTP，DNS，以及文件FTP，邮件的SMTP协议。传输层的协议主要TCP，UDP。网络层的协议主要有IP，ICMP
2.常见的协议
答：DNS，ARP，DHCP，NAT，NAPT，ICMP，IGMP
3.TCP三次握手
答：首先客户端向服务其发送syn报文，syn_num(序列号)为client_isn，并进入SYN_SENT状态，服务器接收到以后响应一个ack报文，其中ack_num=client_isn+1，syn_num=server_isn，并进入SYN_RECV状态，客户端收到以后确认ack_num并响应一个ack报文，其中ack_num为server_isn+1，自此双方建立起连接
4.TCP为什么要三次握手？两次可以吗？四次呢？
答：三次握手是为了却把双方都可以收发，假如两次握手就建立连接，那么就是客户端向服务器发送syn报文，服务器接收到后回复一个ack并建立连接，如果这个ack丢了，那么由于TCP的重发机制，会重发syn报文，此时服务器会再次建立一个连接，这样会导致服务器端的内存资源浪费。因为首先socket就是一个文件句柄会占用内存资源，其次抛开IO复用不说，服务器会给每个连接分配一个线程去处理，每个线程也是会占用资源的。还有一个重要的原因就是两次握手无法防止历史连接初始化连接，比如说有个历史的syn报文早于本次连接的syn到达服务端，那么服务端则接收了历史连接的syn_num并返回一个ack报文，ack_num=syn_num+1，当客户端接收到该ack后，验证ack_num发现不不对，则发送RST报文断开连接，而两次连接则无法防止这种情况，因为三次握手以及可以完全保证TCP连接的建立，则无需四次握手。
5.TCP的四次挥手，为什么需要四次？
答：就拿客户端主动断开为例。首先客户端发送FIN报文，进入FIN_WAIT1状态，服务器收到后响应一个ACK报文，并进入CLOSE_WAIT状态，客户端收到ACK之后进入FIN_WAIT2状态，待服务器将需要发送的都发送完毕后，向客户端发送FIN报文，并进入LAST_ACK状态，客户端收到之后响应ACK并进入TIME_WAIT状态，时间为2MSL(两个最大报文生存周期，一去一回的最长时间)，服务器收到ACK之后正式关闭连接，客户端在等待2MSL时间之后也正是关闭连接。因为当服务器响应ACK之后，它不能同时响应FIN，因为它此时可能还有数据要发，所以只能等待服务其将这些数据发送完后再发起断开连接报文。
6.TCP/UDP的区别
答：TCP是面向连接，而UDP是无连接，这个连接是虚拟的连接，TCP一应一答的模式好比有一个连接，而UDP则没有，只管框框的发。其次TCP是面向字节流的，而UDP则是面向报文的，对于字节流与报文的理解则是TCP传输就像流水，超出TCP携带容量则会进行拆包，而UDP传输则像一块一块的冰，应用层产生多少发多少，若是过大会在IP层进行拆包。还有就是由于TCP拥有重传，拥塞控制等机制，所以TCP传输时可靠的，而UDP则是不可靠的。同理因为TCP拥有拥塞控制，流量控制等手段，所以传输速度相较UDP较低，因此信件啊，文字啊等等需要可靠传输的需要TCP，而视频直播等需要速度的则需要UDP。
7.TCP是如何保证可靠传输的
答：1.有序列号与确认号的控制，使得包可以有序传输给应用层2.通过TCP首部的校验和来判断报文在传输过程中有没有发送变化3.TCP接收端会丢到重复的数据4.流量控制，TCP利用滑动窗口来实现流量控制，当接收端窗口大小小于某个值时，会直接关闭窗口同时通知客户端停止发送5.拥塞控制，发送端拥有一个拥塞窗口，来调节发送的数据量，当网络发生拥塞时，减少数据的发送，网络拥塞的标志是出发了重传机制6.重传机制(ARQ)，在一段时间内收不到响应会触发重传机制。
8.滑动窗口和流量控制
答：TCP的流量控制是基于滑动窗口实现的，通过滑动窗口来控制发送的流量大小。当服务器无法及时处理请求时，会导致窗口越来越小，(服务器与客户端的大小基本保持一致，但是不是绝对的相等，因为是有时间差的)，这样客户端发送的数据量也少，当窗口小到一定程度时，服务器则会直接关闭窗口，停止对方发送。当窗口恢复的时候会通知客户端继续发送。这里也有一个机制，就是防止服务器恢复接收的那个报文丢失，导致双方都在等待。当服务端关闭窗口之后，客户端会隔一段时间会像服务器发送闻讯报文，看是否可以继续发送，当几轮报文之后还无法发送，则会断开连接。
9.拥塞控制
答：TCP为了防止网络拥塞以及缓解网络拥塞，设计了拥塞机制。发送端的发送量由一个拥塞窗口控制与滑动窗口共同控制，发送量时拥塞窗口与滑动窗口的最小值。拥塞控制采用了四种算法。即慢启动，拥塞避免，快重传以及快恢复。慢启动是刚开始发送数据时，拥塞窗口的大小为1，之后每收到一个ack，则窗口大小加一，当窗口达到阈值后，进入拥塞避免状态，每收到一个ack，窗口大小增加窗口大小分之一，当收到不连续的包时，会立马发送一个重复确认，当发送端连续收到三个重复确认则判定是发送了丢包，并立即重传丢失的包(这里有个SACK机制)，这里的快重传值得就是不必等待超时时间而可以直接去快速确定是否丢包，之后会快恢复，阈值与窗口变为原来窗口的二分之一，然后进入拥塞避免状态。
10.HTTP状态码
答：1XX，信息状态码，表示接收的请求正在处理，2XX，成功状态码，表示请求正常处理完毕，200(成功的总状态码)，204(请求收到，但返回为空)，206(请求收到，返回部分数据).3XX重定向状态码，需要进行其他操作以完成请求，301(永久重定向，比如我们输入某个网址，但是跳到了baidu.com)，302(临时重定向，比如未登录的用户访问用户中心则会跳到登录页面)，304表示客户端有缓存服务器的一种回应，服务器.4XX，客户端错误码，服务器无法处理请求，400(错误请求，如语法错误)，403(禁止请求)，404(没有找到文件).5XX服务错误状态码，服务器处理请求出错，500(服务器内部错误)，501(服务器还不具备请求的功能)，502(服务器暂时不可用，可能为了保护系统过载)，503(服务器在维护)
11.HTTP长连接短链接
答：HTTP短链接就是指每次进行一次HTTP操作然后就断开连接。长连接则是指一次链接可以执行多次HTTP操作。HTTP1.0是默认使用短链接，HTTP1.1起默认使用长连接，且报文字段的connection为keep-alive状态，且HTTP的长连接与短连接实质上是TCP协议的长连接与短连接。
12.HTTP是无状态的
答：HTTP是无状态无记忆的，利用cookie与session实现HTTP的有记忆。
13.cookie与session的区别
答：看我博客
14.HTTP1.0/HTTP1.1/HTTP2.0/HTTP3/0的主要区别
答：HTTP1.0是短连接，即每次发送完毕后就会断开连接，再发送再连接，因此HTTP1.1则改为了长连接，且不用等待响应可以连续发送对多个请求，但是是串行，会发生对头阻塞，因此HTTP2.0则改进为实现请求的并发，因此前面请求发生阻塞不会影响后面，且HTTP2.0是基于HTTPS的，还会进行包头的压缩，但是发生丢包时，多个请求都将被阻塞，因此提出了HTTP3.0，它是基于UDP，利用QUIC协议实现了类似TCP的可靠传输，QUIC协议是将TCP三次握手与TLS三次握手合为了3次握手，发生丢包时，不会阻塞所有请求，而是只阻塞对应的流
15.URI与URL的区别
答：我的理解就是URI是定义了某个资源，而URL则是找到某个资源的路径。关于URI与URL之前也写过一篇博客，也查阅了对应的历史感觉URI更像是URL的升级，为了使得当我们改变某个资源的地址时可以使用同样的标识来访问，虽然如今还没实现，然后对于网上大家说的对于一个网址某一部分是URL某一部分是URI，我感觉是没必要的~
16.HTTP与HTTPS
答：由于HTTP是明文传输，所以是不安全的，基于此又设计了HTTPS。HTTP与HTTPS的区别为HTTP的端口为80，而HTTPS的端口为443，然后HTTPS是安全的，所有传输内容都会被加密。
17.HTTPS的四次握手
答：在建立三次握手之后，会进行SSL/TLS四次握手，首先客户端第一次握手即clientHello，向服务器发送一个随机数，以及自己支持的SSL/TLS版本以及加密算法，服务器收到之后回应，即serverHello，向客户端发送一个随机数，以及自己支持的SSL/TLS版本和加密算法，还有自己的证书，客户端收到收到之后，从操作系统获取权威机构CA的公钥并解密证书获取服务器的公钥，然后用服务器公钥加密一个随机数，以及之前所发消息的一个摘要发送给服务器，此时客户端已经有三个随机数了，并用该随机数构建一个密钥，服务器接收到之后用自己的私钥解密，然后用前后生成的三个随机数构建密钥，接着向客户端发送一个摘要，表示之后的通信都将会被采用加密方式
18.网络传输详细
答：首先当开始传输的时候，先会判断目的IP是否是子网，若是子网则直接进行ARP请求(若有ARP缓存则不需要请求)，若不是子网，则查询路由表，获得路由器的IP，然后进行ARP请求，将包发到对应的路由器，由路由器发到目标主机所在局域网的路由器，然后该路由器进行一个ARP请求。(注意交换机是在子网，它里面有一张MAC与网线端口对应的表，交换机端口不具有MAC地址，若对应表里没有对应关系则会将包发往除了源端口的所有网线端口)（路由则是有IP与MAC地址，它是进行网络与网络之间的跳），当跳到目标主机对应的局域网时，会进行ARP查询找到目标主机
19.交换机环路
答：交换机端口之间相连，会导致广播风暴。广播风暴的危害占用网络带宽，导致正常业务无法传输。因为每次都会查找地址表以及进行缓存，所以最终导致CPU被占满，网络崩掉。
